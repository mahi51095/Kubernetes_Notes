# Kubernetes Cluster Setup using Kubeadm (Multi-node)

This document provides a complete guide for setting up a multi-node Kubernetes cluster using `kubeadm`. Each section includes not only the command or instruction but also the **why** behind it—why it is necessary, what problem it solves, and what it does internally.

---

## 📌 Prerequisites

Before starting the Kubernetes cluster setup, ensure the following:

- Minimum 2 CPUs and 2GB RAM on each machine (master and worker nodes).
- Internet access for downloading packages.
- At least 1 master node and 1 or more worker nodes.

---

## 🧩 Step 1: Set Hostnames

```bash
sudo hostnamectl set-hostname master   # on master node
sudo hostnamectl set-hostname worker1  # on worker node
```

### ✅ Why?
Setting a unique and meaningful hostname helps with network identification and cluster communication. Kubernetes uses these names internally to distinguish between nodes.

---

## 🔗 Step 2: Add IP and Hostname Mapping

Edit `/etc/hosts` on **all nodes**:
```bash
sudo nano /etc/hosts
```
Add:
```bash
<master-ip>   master
<worker1-ip>  worker1
```

### ✅ Why?
This ensures that nodes can resolve each other's hostnames to IP addresses, facilitating seamless internal communication.

---

## 🔒 Step 3: Disable Swap Memory

```bash
sudo swapoff -a
```
Comment out the swap line in `/etc/fstab` to make it persistent across reboots.

### ✅ Why?
Kubernetes requires swap to be disabled to ensure proper scheduling and performance. The kubelet won't start if swap is enabled.

---

## 📶 Step 4: Enable Required Kernel Modules

```bash
sudo modprobe overlay
sudo modprobe br_netfilter
```

### ✅ Why?
These kernel modules are required for container networking and bridging between network interfaces, critical for pod communication.

---

## 🔧 Step 5: Update Sysctl Settings for Networking

```bash
cat <<EOF | sudo tee /etc/sysctl.d/kubernetes.conf
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables  = 1
net.ipv4.ip_forward                 = 1
EOF

sudo sysctl --system
```

### ✅ Why?
These sysctl parameters allow Kubernetes to route network traffic properly, especially for communication between pods and services.

---

## 🚧 Step 6: Install Container Runtime (containerd)

```bash
sudo apt update && sudo apt install -y containerd

# Configure containerd
sudo mkdir -p /etc/containerd
sudo containerd config default | sudo tee /etc/containerd/config.toml

# Restart containerd
sudo systemctl restart containerd
sudo systemctl enable containerd
```

### ✅ Why?
Kubernetes needs a container runtime to run containers. `containerd` is a lightweight, industry-standard runtime that integrates well with Kubernetes.

---

## ⚙️ Step 7: Add Kubernetes Repositories

```bash
sudo apt update && sudo apt install -y apt-transport-https curl

curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -

cat <<EOF | sudo tee /etc/apt/sources.list.d/kubernetes.list
deb https://apt.kubernetes.io/ kubernetes-xenial main
EOF
```

### ✅ Why?
This step adds the official Kubernetes package repository to your system, so you can install and update components like kubeadm, kubelet, and kubectl.

---

## 📦 Step 8: Install Kubernetes Components

```bash
sudo apt update
sudo apt install -y kubelet kubeadm kubectl
sudo apt-mark hold kubelet kubeadm kubectl
```

### ✅ Why?
These are the core components of Kubernetes:
- `kubelet`: Runs on each node to manage pods.
- `kubeadm`: Simplifies cluster bootstrapping.
- `kubectl`: CLI tool to interact with the cluster.

`apt-mark hold` ensures they aren’t automatically upgraded, which could break the cluster.

---

## 🔥 Step 9: Initialize Master Node (Control Plane)

```bash
sudo kubeadm init --control-plane-endpoint=master --pod-network-cidr=192.168.0.0/16
```

### ✅ Why?
This command bootstraps the Kubernetes control plane, setting up etcd, API server, controller-manager, and scheduler. The `--pod-network-cidr` matches the range used by most CNI plugins like Calico or Flannel.

---

## 📁 Step 10: Configure kubectl Access on Master

```bash
mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
```

### ✅ Why?
This enables `kubectl` to connect to your cluster using the config generated by `kubeadm`.

---

## 🧪 Step 11: Apply Pod Network (Calico)

```bash
kubectl apply -f https://raw.githubusercontent.com/projectcalico/calico/v3.27.0/manifests/calico.yaml
```

### ✅ Why?
A Container Network Interface (CNI) plugin is necessary to enable pod-to-pod communication. Calico is one of the most popular and production-ready CNIs.

---

## 🔗 Step 12: Join Worker Nodes to Cluster

On each worker node, run the `kubeadm join` command printed during the master initialization. If you lost it, regenerate it on the master:
```bash
kubeadm token create --print-join-command
```

Then run the output on each worker:
```bash
sudo kubeadm join <master-ip>:6443 --token <token> --discovery-token-ca-cert-hash sha256:<hash>
```

### ✅ Why?
This connects worker nodes to the control plane, enabling them to host workloads managed by the Kubernetes scheduler.

---

## ✅ Final Check

Run this on the master node:
```bash
kubectl get nodes
```
You should see the master and all joined worker nodes in `Ready` status.

---

## 🎯 Summary

You’ve now successfully set up a multi-node Kubernetes cluster using `kubeadm`. You understand not only the *how*, but also the *why* behind each step—an essential part of becoming proficient in Kubernetes.

---

Let me know if you'd like to extend this with:
- High availability setup
- Helm & dashboard installation
- Production hardening tips
